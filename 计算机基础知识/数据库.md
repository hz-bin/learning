## 事务的ACID特性
- 事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。
- 事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。
- 原子性：事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。（原子性实现原理 - Undo Log）
- 一致性：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- 隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。（隔离性实现原理 - 锁）
- 持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。（持久性实现原理 - Redo Log）

## 隔离级别
- Read Uncommitted（读取未提交）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
- Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。
- Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
- Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。

```
脏读：一个事务还未提交，另外一个事务访问此事务修改的数据，并使用，读取了事务中间状态数据。
不可重复读：一个事务读取同一条记录2次，得到的结果不一致，由于在2次读取之间另外一个事务对此行数据进行了修改。
幻读：一个事务读取2次，得到的记录条数不一致，由于2次读取之间另外一个事务对数据进行了增删。
```
不同事务隔离级别有不同的效果：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
|---|---|---|---|
| 读未提交 | √ | √ | √ |
| 读已提交 | × | √ | √ |
| 可重复读 | × | × | √ |
| 可串行化 | × | × | × |


## 数据库引擎InnoDB、MyISAM
- InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。
- MyISAM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyISAM中存储了表的行数。
- https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL?id=myisam%e5%92%8cinnodb%e5%8c%ba%e5%88%ab

## MVCC实现原理
- Multi-Version Concurrency Control，即多版本并发控制。
- InnoDB 的 MVCC, 是通过在每行记录后面保存两个隐藏的列来实现的, 这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值, 而是系统版本号 (可以理解为事务的 ID)，每次开始一个新的事务，系统版本号就会自动递增；当删除一条数据的时候，该数据的删除时间列就会存上当前事务的版本号 ；事务开始时刻的系统版本号会作为事务的 ID；
- https://juejin.cn/post/6844903986143690765

## 数据库索引及底层实现
- 唯一索引：唯一索引是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中不可以重复
- 非唯一索引：非唯一索引是在表上一个或者多个字段组合建立的索引，这个或者这些字段的值组合起来在表中可以重复，不要求唯一。
- 主键索引（主索引）：主键索引（主索引）是唯一索引的特定类型。表中创建主键时自动创建的索引 。一个表只能建立一个主索引。
- 聚集索引/非聚集索引：聚集索引（聚簇索引），表中记录的物理顺序与键值的索引顺序相同。一个表只能有一个聚集索引。InnoDB 使用 B+ 树，既可以保存实际数据，也可以加速数据搜索，这就是聚簇索引
- https://veal98.gitee.io/cs-wiki/#/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97?id=%e4%b9%9d%e3%80%81%e7%b4%a2%e5%bc%95-%e2%ad%90

## 分布式事务
https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653193461&idx=1&sn=d69ccec780ae6d3b0c722cf09fa154d1&chksm=8c99f62fbbee7f39cd221bd0ecc9105a5c16e353d82d2407e7f295da9f9172cfd4889d3f12c8&scene=21#wechat_redirect)
- 分布式事务用于在分布式系统中保证不同节点之间的数据一致性。
- 分布式事务的实现有很多种，最具有代表性的是由Oracle Tuxedo系统提出的XA分布式事务协议。
- XA协议包含两阶段提交（2PC）和三阶段提交（3PC）两种实现，这里我们重点介绍两阶段提交的具体过程。
- 事务的发起者称协调者，事务的执行者称参与者。
![image](../image/2PC第一阶段.jpg)
- 第一阶段：
    - 在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。
    - 在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。
    - 当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。
![image](../image/2PC第二阶段.jpg)
- 第二阶段：
    - 在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。
    - 接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。
    - 当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。
- XA两阶段提交的不足：
    - 1.性能问题：XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。
    - 2.协调者单点故障问题：事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。
    - 3.丢失消息导致的不一致问题：在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。
- 如果避免XA两阶段提交的种种问题呢？有许多其他的分布式事务方案可供选择：
    - 1.XA三阶段提交：XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。CanCommit、PreCommit、DoCommit
    - 2.MQ事务：利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。
    - 3.TCC事务：TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。



## 缓存穿透、击穿、雪崩
- 缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求
- 缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。
- 缓存雪崩是因为大面积的缓存失效，打崩了DB

## mysql主从复制
https://zhuanlan.zhihu.com/p/342666786
- 主从复制原理：主从复制中有两个很重要的日志文件，binlog和relay log，分别位于主库与从库中。其中 binlog 是主从复制的基础，通过将操作事件写入 binlog 通过 I/O 线程传送至从库进行同步。
- 主从延迟原因：
    - 从库中 SQL 线程重放的过程是随机写盘的，并且 SQL 线程是单线程的，因此数据来不及重放的话就会导致主从延迟。
    - 主库并发高会导致写操作不断写入 binlog，对于 SQL 线程说可能会应接不暇，也会产生主从延迟。
    - 重放过程中如果遇到锁等待也是产生延迟的原因之一。
- 主从延迟处理：MySQL 5.6版本以后通过并行复制的方式来解决 SQL 单线程产生的主从延迟问题。对于低版本来说，可以通过降低主库的并发来解决。如果对数据实时性要求比较严格的话，可以通过读主库来达到目的。

## 重点掌握

- 数据库类别

- 关系型数据库和非关系型数据库区别

### MySQL：

#### SQL常见语句

#### MySQL内链接，外链接（左链接、右链接、全链接）

#### MySQL索引类型和原理

#### MySQL事务实现原理ACID

#### MySQL数据存储引擎

#### MySQL主从复制原理、作用和实现

#### MySQL日记系统redo log、binlog、undo log
- 物理日志redo log和逻辑日志binlog
- redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
- redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。
- redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

#### MVCC实现原理

#### Sql优化思路

#### 范式理论

#### 数据库高并发解决方法


## 推荐书籍
- 《高性能 Mysql》能够加深对Mysql的理解和使用

- 《Redis设计与实现》比较全面的书，可以多看看